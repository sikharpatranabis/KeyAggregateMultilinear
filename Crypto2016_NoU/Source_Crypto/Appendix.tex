\appendix

\section{Relaxing Assumptions 3.5 and 4.5}
\label{app_sec:relaxation}

In the two KAC constructions presented so far, we have assumed that all plaintext messages $\mathcal{M}$ may be efficiently embedded as elements in the respective target multilinear groups. However, embedding any general class of data as group elements is extremely challenging and requires \emph{public samplability} - a feature that makes a multilinear map constructions insecure. However, a workaround may be readily proposed. We first note that in any ciphertext output by \textbf{Encrypt}, the message $\mathcal{M}$ is essentially multiplied with a random secret group element $\rho$. Rather than embedding $\mathcal{M}$ as a group element, we propose hashing $\rho$ using a collision resistant hash function $H$, and then outputting $\mathcal{M}\odot H(\rho)$ in the ciphertext (here $\odot$ denotes an appropriate operator). In order to ensure that the constructions are still provably secure in the standard model, we propose that $H$ be chosen from the family of \emph{smooth projective hash functions} \cite{cramer2002universal}, that do not require the use of random oracles to prove security. Smooth projective hash functions are very efficient to construct and can be designed to be collision-resistant \cite{abdalla2009smooth}, making them an ideal choice for our constructions.

\section{CCA Secure Basic KAC Using Asymmetric Multilinear Maps}
\label{app_sec:CCA1}

In this section we demonstrate how to extend the basic identity-based KAC construction (for single owner - single user scenario) to obtain non-adaptive chosen ciphertext security while maintaining full collusion resistance. We have the following additional requirements for achieving CCA security:

\begin{itemize}
 \item A signature scheme $(SigKeyGen,Sign,Verify)$. 
 \item A collision resistant hash function for mapping verification keys to $\mathbb{Z}_q$. 
\end{itemize}

For simplicity of presentation, we assume here that the signature verification keys are encoded as elements of $\mathbb{Z}_q$. We avoid any further mention of the hash function in the forthcoming discussion, since it is implicitly assumed that any signature value we refer to is essentially the hash value corresponding to the original signature.

\subsubsection{Construction.}  It is to be noted that unlike non-adaptive CPA security, non-adaptive CCA security for our proposed KAC under the $m$-HDHE assumption requires that the system handles at most $N-1$ data classes, where $N=2^m-1$. The reason for this will be apparent in the proof. hence for consistency of notation, we describe here the construction of the CCA-secure KAC for $N-1$ data classes. Recall that \textbf{SetUp}$''(1^{\lambda},\mathbf{m})$ is the setup algorithm for an asymmetric multilinear map, where groups have prime order $q$ (where $q$ is a $\lambda$ bit prime).\\

% \begin{enumerate}
\noindent\textbf{SetUp}$(1^{\lambda},m)$: Takes as input the length $m$ of identities and the group order parameter $\lambda$. Let $\mathcal{ID}=\{0,1\}^m\backslash(\{0\}^m\cup\{1\}^m)$ be the data class identity space with $N-1$ classes. Also, let $\mathbf{m}$ be the $m+1$ length vector consisting of all ones. Let $param''\leftarrow SetUp''(1^{\lambda},2\mathbf{m})$ be the public parameters for a multilinear map, with $\mathbb{G}_{2\mathbf{m}}$ being the target group. Next, choose a random $\alpha\in \mathbb{Z}_q$. Set $X_j=g^{\alpha^{(2^j)}}_{\mathbf{x}_j}$ for $0\leq j\leq m-1$ and $X_m=g^{\alpha^{(2^m+1)}}_{\mathbf{x}_m}$. Output the public parameter tuple $param$ as
\begin{equation}
 param = (param'',\{X_j\}_{j\in\{0,\cdots,m\}})\nonumber
\end{equation}
\noindent Discard $\alpha$ after $param$ has been output.\\ 
 
\noindent \textbf{KeyGen}(): Same as in the construction of Section \ref{subsec:construction}.\\
 
\noindent \textbf{Encrypt}$(param,PK,i,\mathcal{M})$: Run the $SigKeyGen$ algorithm to obtain a signature signing key $K_{SIG}$ and a verification key $V_{SIG} \in \mathbb{Z}_q$. Randomly choose $t\in\mathbb{Z}_q$. Compute 
\begin{equation}
 \mathcal{C}'=(g^{t}_{\mathbf{m}},(PK.Y_i.Y^{V_{SIG}}_{2^m-1})^{t},\mathcal{M}.g^{t\alpha^{(2^m)}}_{2\mathbf{m}})\nonumber
\end{equation} 
\noindent and output the ciphertext as
\begin{eqnarray}
 \mathcal{C}&=&(\mathcal{C}',Sign(\mathcal{C}',K_{SIG}),V_{SIG}) \nonumber
\end{eqnarray} 
 
\noindent \textbf{Extract}$(param,msk,\mathcal{S})$: Same as in the construction of Section \ref{subsec:construction}.\\
 
\noindent \textbf{Decrypt}$(param,\mathcal{C},i,\mathcal{S},K_{\mathcal{S}})$: Let $\mathcal{C}=((c_0,c_1,c_2),\sigma,V_{SIG})$. Verify that $\sigma$ is a valid signature of $(c_0,c_1,c_2)$ under the key $V_{SIG}$. If not, output $\bot$. Also, if $i\notin\mathcal{S}$, output $\bot$. Otherwise, set 
\begin{eqnarray}
  SIG_{\mathcal{S}} &=& \prod_{v\in\mathcal{S}}Y^{V_{SIG}}_{2^{m+1}-1-v}\nonumber\\
  a_{\mathcal{S}} &=& \prod_{v\in\mathcal{S},v\neq i}Y_{2^m-v+i}\nonumber\\
  b_{\mathcal{S}} &=& \prod_{v\in\mathcal{S}}Y_{2^m-v}\nonumber  
\end{eqnarray}
\noindent Note that these can be computed as $1\leq i,v \leq N-1(=2^m-2)$. \emph{This is precisely why we allow only $N-1$ data classes}.  Next, pick a random $w\in \mathbb{Z}_q$ and set
 \begin{eqnarray}
  \hat{h}_1 &=& (K_{\mathcal{S}}.SIG_{\mathcal{S}}.a_{\mathcal{S}}.(PK.Y_i.Y^{V_{SIG}}_{2^m-1})^w)\nonumber\\
  \hat{h}_2 &=& (b_{\mathcal{S}}.g^w_{\mathbf{m}}) \nonumber
 \end{eqnarray}
 \noindent Output the decrypted message 
 \begin{equation}
  \hat{\mathcal{M}} = c_2\frac{{e}(\hat{h}_1,c_0)}{{e}(\hat{h}_2,c_1)}\nonumber
 \end{equation}
\noindent The proof of correctness of this scheme is presented below.

\begin{equation}
\begin{split}
 \hat{\mathcal{M}} &= c_3\frac{{e}(\hat{h}_1,c_1)}{{e}(\hat{h}_2,c_2)}\\
 &= c_3.\left(\frac{e\left(K_{\mathcal{S}}.SIG_{\mathcal{S}}.a_{\mathcal{S}},g^{t}_{\mathbf{m}}\right)}{e\left(b_{\mathcal{S}},(PK.Y_i.Y^{V_{SIG}}_{2^m-1})^{t}\right)}\right).\left(\frac{e\left(\left(PK.Y_i.Y^{V_{SIG}}_{2^m-1}\right)^w,g^{t}_{\mathbf{m}}\right)}{e\left(g^w_{\mathbf{m}},(PK.Y_i.Y^{V_{SIG}}_{2^m-1})^{t}\right)}\right)\\
 &=c_3.\left(\frac{e\left(K_{\mathcal{S}},g^{t}_{\mathbf{m}}\right)}{e\left(b_{\mathcal{S}},PK^{t}\right)}\right).\left(\frac{e\left(SIG_{\mathcal{S}},g^{t}_{\mathbf{m}}\right)}{e\left(b_{\mathcal{S}},\left(Y^{V_{SIG}}_{2^m-1}\right)^{t}\right)}\right).\left(\frac{e\left(a_{\mathcal{S}},g^{t}_{\mathbf{m}}\right)}{e\left(b_{\mathcal{S}},Y^{t}_i\right)}\right)\\
 &=c_3\frac{e(\prod_{v\in\mathcal{S},v\neq i}Y_{2^m-v+i},g^{t}_{\mathbf{m}})}{e(\prod_{v\in\mathcal{S}}Y_{2^m-v},Y_i^{t})}\\
 &=\frac{\mathcal{M}.g^{t\alpha^{(2^m)}}_{2\mathbf{m}}}{e(Y_{2^m},g^{t}_{\mathbf{m}})}\\
 &=\mathcal{M}\nonumber
\end{split}
\end{equation}

\noindent Note that the overhead for the ciphertext, aggregate key, public parameters, and the private and public keys, remains unchanged. The main change from the original scheme is in the fact that decryption requires a randomization value $w\in\mathbb{Z}_q$.

\subsubsection{Claim B.1.} \textit{For a given $i\in\mathcal{S}$, the pair $(\hat{h}_1,\hat{h}_2)$ is chosen from the following distribution 
\begin{equation}
\left(\left({Y_{2^m}}\right)^{-1}.\left(PK.Y_i.Y^{V_{SIG}}_{2^m-1}\right)^x,\left(g_{\mathbf{m}}\right)^x\right)\nonumber
\end{equation}
\noindent where $x$ is uniformly randomly chosen from $\mathbb{Z}_q$.}\\

\noindent{\textbf{Proof.}} We have 
\begin{equation}
\begin{split}
 \hat{h}_2 &= \left(b_{\mathcal{S}}.g^w_{\mathbf{m}}\right)\\
 &= g^{\left(w+\left(\sum_{v\in\mathcal{S}}\alpha^{2^m-v}\right)\right)}_{\mathbf{m}}\\
 &= \left(g_{\mathbf{m}}\right)^x\nonumber
\end{split}
\end{equation}
\noindent Also, observe the following:
\begin{equation}
\begin{split}
 \hat{h}_1 &= \left(K_{\mathcal{S}}.SIG_{\mathcal{S}}.a_{\mathcal{S}}\right).\left(PK.Y_i.Y^{V_{SIG}}_{2^m-1}\right)^w\\
 &= \left({Y_{2^m}}\right)^{-1}\left(K_{\mathcal{S}}.SIG_{\mathcal{S}}.a_{\mathcal{S}}.{Y_{2^m}}\right).\left(PK.Y_i.Y^{V_{SIG}}_{2^m-1}\right)^w\\
 &= \left({Y_{2^m}}\right)^{-1}\left(PK.Y_i.Y^{V_{SIG}}_{2^m-1}\right)^{\left(\sum_{v\in\mathcal{S}}\alpha^{2^m-v}\right)}.\left(PK.Y_i.Y^{V_{SIG}}_{2^m-1}\right)^w\\
 &= \left({Y_{2^m}}\right)^{-1}\left(PK.Y_i.Y^{V_{SIG}}_{2^m-1}\right)^{(w+\left(\sum_{v\in\mathcal{S}}\alpha^{2^m-v}\right))}\\
 &= \left({Y_{2^m}}\right)^{-1}\left(PK.Y_i.Y^{V_{SIG}}_{2^m-1}\right)^x\nonumber
\end{split} 
\end{equation}


\noindent This randomization slows down the decryption by a factor of two, but is vital from the point of view of CCA-security. Note that the distribution $(\hat{h}_1,\hat{h}_2)$ depends \emph{only on the data class $i$ for the message $\mathcal{M}$ to be decrypted} and is \emph{completely independent of the subset $\mathcal{S}$ used to encrypt it}. 

\subsubsection{CCA Security.} We next prove the non-adaptive CCA security of this scheme. Note that a signature scheme $(SigKeyGen,Sign,Verify)$ is said to be $(\epsilon,q_S)$ strongly existentially unforgeable if no poly-time adversary, making at most $q_{S}$ signature signature queries, fails to produce some new message-signature pair with probability at least $\epsilon$. For a more complete description, refer \cite{canetti2004chosen}.

\subsubsection{Theorem B.2.} \textit{Let \textbf{Setup}$''$ be the setup algorithm for an asymmetric multilinear map, and let the decisional $m$-Hybrid Diffie-Hellman Exponent assumption holds for {SetUp}$''$. Also, assume that the signature scheme is strongly existentially unforgeable. Then the modified KAC construction for $N-1$ data classes presented above is non-adaptively CCA secure.}

\subsubsection{Proof.} Once again, let $\mathcal{A}$ be a poly-time adversary such that $|Adv_{\mathcal{A},N-1}-\frac{1}{2}| > \epsilon_1+\epsilon_2$ for the proposed KAC system parameterized with an identity space $\mathcal{ID}$ of size $N-1=2^m-2$. Let the signature scheme is $(\epsilon_2,q_S)$ strongly existentially unforgeable. We build an algorithm $\mathcal{B}$ that has advantage at least $\epsilon_1$ in solving the decisional $m$-HDHE problem for \textbf{Setup}$''$. $\mathcal{B}$ takes as input a random $m$-HDHE challenge $(param'',\{X_j\}_{j\in\{0,\cdots,m\}},V,Z)$ where:
\begin{itemize}
 \item $param''\leftarrow SetUp''(1^{\lambda},2\mathbf{m})$ 
 \item $X_j=g^{\alpha^{(2^j)}}_{\mathbf{x}_j}$ for $0\leq j \leq m-1$
 \item $X_m=g^{\alpha^{(2^m+1)}}_{\mathbf{x}_m}$
 \item $V=g^{t}_{\mathbf{m}}$ for a random $t\in\mathbb{Z}_q$, $q$ being a $\lambda$ bit prime
 \item $Z$ is either $g^{t\alpha^{(2^m)}}_{2\mathbf{m}}$ or a random element of $\mathbb{G}_{2\mathbf{m}}$
\end{itemize}
\noindent $\mathcal{B}$ then proceeds as follows.\\

% \begin{enumerate}
\noindent \textbf{Commit:} $\mathcal{B}$ runs $\mathcal{A}$ and receives the set ${\mathcal{S}}^{*}$ of data classes that $\mathcal{A}$ wishes to be challenged on. $\mathcal{B}$ then randomly chooses a data class $i\in{\mathcal{S}}^{*}$ and provides it to $\mathcal{A}$.\\
 
\noindent \textbf{SetUp}: $\mathcal{B}$ should generate the public $param$, public key $PK$ and the aggregate key $K_{\overline{{\mathcal{S}}^{*}}}$ and provide them to $\mathcal{A}$. Algorithm $\mathcal{B}$ first runs the $SigKeyGen$ algorithm to obtain a signature signing key $K^{*}_{SIG}$ and a corresponding verification key $V^{*}_{SIG} \in \mathbb{Z}_q$. The various items to be provided to $\mathcal{A}$ are generated as follows.
%  \vspace{-0.6mm}
\begin{itemize}
  \item $param$ is set as $(param'',\{X_i\}_{i\in\{0,\cdots,m\}})\nonumber$.
  \item $PK$ is set as $\left({g^u_{\mathbf{m}}}\right)/{\left(Y_i.Y^{V^{*}_{SIG}}_{2^m-1}\right)}$ where $u$ is chosen uniformly at random from $\mathbb{Z}_q$ and $Y_i,Y_{2^m-1}$ are computed as mentioned in Claim 3.1. Note that this is equivalent to setting $msk=u-\alpha^i-V^{*}_{SIG}\alpha^{2^m-1}$.
  \item $\mathcal{B}$ then computes   
  \begin{equation}
   K_{\overline{{\mathcal{S}}^{*}}} = \prod_{v\notin{\mathcal{S}}^{*}}\frac{Y^{u}_{2^m-v}}{(Y_{2^m-v+i}).(Y^{V^{*}_{SIG}}_{2^{m+1}-1-v})}\nonumber
  \end{equation}
  \noindent Observe that $K_{\overline{{\mathcal{S}}^{*}}}=\prod_{v\notin{\mathcal{S}}^{*}}PK^{\alpha^{2^m-v}}$, as desired. Moreover, $\mathcal{B}$ is aware that $i\notin \overline{{\mathcal{S}}^{*}}$ (implying $i\neq v$), and hence has all the resources to compute $K_{\overline{{\mathcal{S}}^{*}}}$.  
\end{itemize}
 
\noindent Since the $g_{\mathbf{m}}$, $\alpha$, $u$ and $t$ values are chosen uniformly at random, \emph{all parameters and keys have an identical distribution to that in the actual construction}.\\

\noindent\textbf{Query Phase 1}: Algorithm $\mathcal{A}$ now issues decryption queries. Let $(\mathcal{C},v)$ be a decryption query $\mathcal{C}$ is obtained by $\mathcal{A}$ using some subset $\mathcal{S}$ containing $v$. However, $\mathcal{B}$ is not given the knowledge of $\mathcal{S}$. Let $\mathcal{C}=((c_0,c_1,c_2),\sigma,V_{SIG})$. Algorithm $\mathcal{B}$ first runs $Verify$ to check if the signature $\sigma$ is valid on $(c_0,c_1,c_2)$ using $V_{SIG}$. If invalid, $\mathcal{B}$ returns $\bot$. If $V_{SIG} = V^{*}_{SIG}$, $\mathcal{B}$ outputs a random bit $b\in\{0,1\}$ and \emph{aborts} the simulation. Otherwise, the challenger picks a random $x\in\mathbb{Z}_q$. It then sets
\begin{eqnarray}
 \hat{h}_0&=&Y^{(V_{SIG}-V^{*}_{SIG})}_{2^m-1}.Y_v.Y^{-1}_i\nonumber\\
 \hat{h'}_0&=&(Y_{v+1}/Y_{i+1})^{\frac{1}{(V_{SIG}-V^{*}_{SIG})}}\nonumber \\
 \hat{h}_2&=&g^{x}_{\mathbf{m}}.Y^{\frac{1}{(V_{SIG}-V^{*}_{SIG})}}_1\nonumber\\
 \hat{h}_1&=&\left(\hat{h}_2\right)^u.\left(\hat{h}_0\right)^x.\left(\hat{h'}_0\right) \nonumber 
\end{eqnarray}
\noindent Note that $\hat{h'}_0$ can be computed following Claim 3.1 as $1\leq i,v \leq 2^m-2$. $\mathcal{B}$ responds with $\mathcal{M}'=c_2\frac{{e}(\hat{h}_1,c_0)}{{e}(\hat{h}_2,c_1)}$. 

\subsubsection{Claim B.3.} \textit{$\mathcal{B}$'s response is exactly as in a real attack scenario, that is, for some $x'$ chosen uniformly at random from $\mathbb{Z}_q$, we have} 
\begin{equation}
\hat{h}_1 = \left({Y_{2^m}}\right)^{-1}.\left(PK.Y_v.Y^{V_{SIG}}_{2^m-1}\right)^{x'}  \text{ and }  \hat{h}_2 = g^{x'}_{\mathbf{m}}\nonumber
\end{equation}

\noindent{\textbf{Proof.}} Set $x'=x+\frac{\alpha}{(V_{SIG}-V^{*}_{SIG})}$. Since $x$ is uniform in $\mathbb{Z}_q$, so is $x'$. Now, observe that 

\begin{equation}
\begin{split}
 \hat{h}_2&=g^{x}_{\mathbf{m}}.Y^{\frac{1}{(V_{SIG}-V^{*}_{SIG})}}_1\\
 &= g^{x}_{\mathbf{m}}.g^{\frac{\alpha}{(V_{SIG}-V^{*}_{SIG})}}_{\mathbf{m}}\\
 &= g^{x'}_{\mathbf{m}}\nonumber
\end{split}
\end{equation}

\noindent Next, observe the following:
\begin{equation}
\begin{split}
  \hat{h}_1&=\left(\hat{h}_2\right)^u.\left(\hat{h}_0\right)^x.\left(\hat{h'}_0\right)\\
  &=\left(g^{u}_{\mathbf{m}}\right)^{x'}.\left(Y^{x\left(V_{SIG}-V^{*}_{SIG}\right)}_{2^m-1}\right).\left(Y_{v}/Y_{i}\right)^{\left(x+\frac{\alpha}{(V_{SIG}-V^{*}_{SIG})}\right)}\\
  &= \left(PK.Y_i.Y^{V^{*}_{SIG}}_{2^m-1}\right)^{x'}.\left(Y^{x\left(V_{SIG}-V^{*}_{SIG}\right)}_{2^m-1}\right).\left(Y_{v}/Y_{i}\right)^{x'}\\
  &= \left(PK.Y_v.Y^{V_{SIG}}_{2^m-1}\right)^{x'}.\left(Y^{\left(x-x'\right)\left(V_{SIG}-V^{*}_{SIG}\right)}_{2^m-1}\right)\\
  &= \left(PK.Y_v.Y^{V_{SIG}}_{2^m-1}\right)^{x'}.\left(Y^{-\alpha}_{2^m-1}\right)\\
  &= \left({Y_{2^m}}\right)^{-1}.\left(PK.Y_v.Y^{V_{SIG}}_{2^m-1}\right)^{x'}\nonumber
\end{split}
\end{equation}
 

\noindent Thus, $\mathcal{B}$'s response is identical to \textbf{Decrypt}$(\mathcal{C},v,\mathcal{S},K_{\mathcal{S}})$, even though $\mathcal{B}$ does not possess the knowledge of the subset $\mathcal{S}$ used by $\mathcal{A}$ to obtain $\mathcal{C}$.\\
 
\noindent \textbf{Challenge}: $\mathcal{A}$ picks at random two messages $\mathcal{M}_0$ and $\mathcal{M}_1$ from the set of possible plaintext messages in $\mathbb{G}_{2\mathbf{m}}$, and provides them to $\mathcal{B}$. $\mathcal{B}$ randomly picks $b\in\{0,1\}$, and sets 
\begin{eqnarray}
 \mathcal{C}&=&(V,V^u,\mathcal{M}_b.Z) \nonumber\\
 \mathcal{C}^{*}&=&(\mathcal{C},Sign(\mathcal{C},K^{*}_{SIG}),V^{*}_{SIG})\nonumber
\end{eqnarray}
\noindent The challenge posed to $\mathcal{A}$ is $(\mathcal{C}^{*},\mathcal{M}_0,\mathcal{M}_1)$. It can be easily shown that when $Z=g^{t\alpha^{(2^m)}}_{2\mathbf{m}}$ (i.e. the input to $\mathcal{B}$ is a valid $m$-HDHE tuple), then this is a valid challenge to $\mathcal{A}$ as in a real attack.\\

\noindent\textbf{Query Phase 2}: Same as in query phase 1.\\
 
\noindent \textbf{Guess}: The adversary $\mathcal{A}$ outputs a guess $b'$ of $b$. If $b' = b$, $\mathcal{B}$ outputs $0$ (indicating that $Z=g^{t\alpha^{(2^m)}}_{2\mathbf{m}}$). Otherwise, it outputs $1$ (indicating that $Z$ is a random element in $\mathbb{G}_{2\mathbf{m}}$).\\ 

\noindent We now bound the probability that $\mathcal{B}$ aborts the simulation as a result of one of the decryption queries by $\mathcal{A}$. We claim that $Pr[\textbf{abort}]<\epsilon_2$; otherwise one can use $\mathcal{A}$ to forge signatures with probability at least $\epsilon_2$. A very brief proof of this may be stated as follows. We may construct a simulator that knows the secret $u$ and receives $K^{*}_{SIG}$ as a challenge in an existential forgery game. $\mathcal{A}$ can then cause an abort by producing a query that leads to an existential forgery under $K^{*}_{SIG}$ on some ciphertext. Our simulator uses this forgery to win the existential forgery game. Only one chosen message query is made by the adversary during the game to generate the signature corresponding to the challenge ciphertext. Thus, $Pr[\text{abort}]<\epsilon_2$.

We conclude that $\mathcal{B}$ has the same advantage $\epsilon$ as $\mathcal{A}$, which must therefore be negligible, as desired. This completes the proof of Theorem B.2. \hfill\qed

Similar CCA secure extensions can also be made to the generalized KAC construction for the multi-user scenario.

% \subsection{Proof of Security }
% \label{app_subsec:CPA_general}

% \subsection{Correctness}
% \label{app_subsec:proofCCA}
% 
% We show that the CCA-secure construction is correct, that is, $\hat{\mathcal{M}}=\mathcal{M}$ as follows.
% 
% 
% \subsection{Proof of Claim B.1}
% \label{app_subsec:claimB.1}
% 
% Recall that we have set 
% \begin{eqnarray}
%  \hat{h}_1 &=& (K_{\mathcal{S}}.SIG_{\mathcal{S}}.a_{\mathcal{S}}.(PK.Y_i.Y^{V_{SIG}}_{2^m-1})^w)\nonumber\\
%  \hat{h}_2 &=& (b_{\mathcal{S}}.g^w_{\mathbf{m}}) \nonumber
% \end{eqnarray}
% \noindent where $w$ is uniformly randomly chosen from $\mathbb{Z}_q$. Set $x=w+\left(\sum_{v\in\mathcal{S}}\alpha^{2^m-v}\right)$. Quite evidently $x$ is also uniformly random in $\mathbb{Z}_q$. Now, \hfill\qed
% 
% \subsection{Proof of Claim B.3}
% \label{app_subsec:claimB.3}
% 
% Recall that we have set
% \begin{eqnarray}
%  \hat{h}_0&=&Y^{(V_{SIG}-V^{*}_{SIG})}_{2^m-1}.Y_v.Y^{-1}_i\nonumber\\
%  \hat{h'}_0&=&(Y_{v+1}/Y_{i+1})^{\frac{1}{(V_{SIG}-V^{*}_{SIG})}}\nonumber \\
%  \hat{h}_2&=&g^{x}_{\mathbf{m}}.Y^{\frac{1}{(V_{SIG}-V^{*}_{SIG})}}_1\nonumber\\
%  \hat{h}_1&=&\left(\hat{h}_2\right)^u.\left(\hat{h}_0\right)^x.\left(\hat{h'}_0\right) \nonumber 
% \end{eqnarray}
% \noindent where $x$ is chosen at random from $\mathbb{Z}_q$. \noindent This concludes the proof of Claim B.3.\hfill\qed


% \section{KAC Using Symmetric Multilinear Maps}

% \subsection{Correctness of the Basic CPA Secure KAC Construction}
% \label{app_sec:correctness_2}
% 
% Correctness may be established as follows.
% 
% \begin{equation}
% \begin{split}
%  \hat{\mathcal{M}}&=c_2\frac{{e}(K_{\mathcal{S}}.a_{\mathcal{S}},c_0)}{{e}(b_{\mathcal{S}},c_1)}\\
%  &=c_2\frac{e(\prod_{v\in\mathcal{S}}\left({Y_{2^m-1-v}}\right)^{\gamma}.\prod_{v\in\mathcal{S},v\neq i}Y_{2^m-1-v+i},g^{t}_{l})}{e(\prod_{v\in\mathcal{S}}Y_{2^m-1-v},(PK.\hat{Y}_i)^{t})}\\
%  &=c_2\frac{e(\prod_{v\in\mathcal{S},v\neq i}Y_{2^m-1-v+i},g^{t}_{l})}{e(\prod_{v\in\mathcal{S}}Y_{2^m-1-v},(\hat{Y}_i)^{t})}\\
%  &=\frac{\mathcal{M}.g^{t\alpha^{(2^m-1)}}_{m+l-1}}{e(Y_{2^m-1},g^{t}_{l})}\\
%  &=\mathcal{M}\nonumber
% \end{split} 
% \end{equation}
% 
% \subsection{Proof of Theeorem 4.6}
% \label{app_sec:proof}
% 
% Let $\mathcal{A}$ be a poly-time adversary such that $|Adv_{\mathcal{A},N}-\frac{1}{2}| > \epsilon$ for the proposed KAC system parameterized with an identity space $\mathcal{ID}$ of size $N$, where $N=\binom{m}{l}$ and $\epsilon$ is a non-negligible positive constant. We build an algorithm $\mathcal{B}$ that has advantage at least $\epsilon$ in solving the decisional $(m,l)$-MDHE problem for \textbf{Setup}$'$. $\mathcal{B}$ takes as input a random $(m,l)$-MDHE challenge consisting of the tuple $(param',\{X_j\}_{j\in\{0,\cdots,m\}},V,Z)$, where:
% \begin{itemize}
%  \item $param'\leftarrow SetUp'(1^{\lambda},m+l-1)$
%  \item $X_j=g^{\alpha^{(2^j)}}_{1}$ for $0\leq j \leq m$
%  \item $V=g^{t}_{l}$ for a random $t\in\mathbb{Z}_q$ (where $q$ is a $\lambda$ bit prime)
%  \item $Z$ is either $g^{t\alpha^{(2^m-1)}}_{m+l-1}$ or a random element of $\mathbb{G}_{m+l-1}$.
% \end{itemize}
% \noindent $\mathcal{B}$ then proceeds as follows.\\
% 
% % \begin{enumerate}
% \noindent \textbf{Commit:} $\mathcal{B}$ runs $\mathcal{A}$ and receives the set $\mathcal{S}$ of data classes that $\mathcal{A}$ wishes to be challenged on. $\mathcal{B}$ then randomly chooses a data class $i\in\mathcal{S}$ and provides it to $\mathcal{A}$.\\
%  
% \noindent \textbf{SetUp}: $\mathcal{B}$ should generate the public $param$, the public key $PK$ and the aggregate key $K_{\overline{\mathcal{S}}}$, and provide them to $\mathcal{A}$. They are generated as follows.
% %  \vspace{-0.6mm}
% \begin{itemize}
%   \item $param$ is set as $(param',\{X_j\}_{j\in\{0,\cdots,m\}})$.
%   \item $PK$ is set as $({g^u_{l}}/{\hat{Y}_i})$ where $u$ is chosen uniformly at random from $\mathbb{Z}_q$ and $\hat{Y}_i$ is computed as mentioned in Claim 4.2. 
%   \item $\mathcal{B}$ then computes   
%   \begin{equation}
%    K_{\overline{\mathcal{S}}} = \prod_{v\notin\mathcal{S}}\frac{\left(Y_{2^m-1-v}\right)^u}{Y_{2^m-1-v+i}}\nonumber
%   \end{equation}
%   \noindent It is easy to see that $K_{\overline{\mathcal{S}}}$ is a valid aggregate key.   
% \end{itemize}
%  
% \noindent Since the $g_{m-1}$, $g_{l}$, $\alpha$, $u$, and $t$ values are chosen uniformly at random, \emph{all the parameters and the keys have an identical distribution to that in the actual construction}.\\
%  
% \noindent \textbf{Challenge}: $\mathcal{A}$ picks at random two messages $\mathcal{M}_0$ and $\mathcal{M}_1$ from the set of possible plaintext messages in $\mathbb{G}_{m+l-1}$, and provides them to $\mathcal{B}$. $\mathcal{B}$ randomly picks $b\in\{0,1\}$, and sets the challenge as $(\mathcal{C},\mathcal{M}_0,\mathcal{M}_1)$, where 
% \begin{equation}
%  \mathcal{C}=(V,V^u,\mathcal{M}_b.Z) \nonumber
% \end{equation}
% \noindent Once again, as in the proof of Theorem 3.7, whenever $Z=g^{t\alpha^{(2^m-1)}}_{m+l-1}$ (i.e. the input to $\mathcal{B}$ is a valid $(m,l)$-MDHE tuple), then $(\mathcal{C},\mathcal{M}_0,\mathcal{M}_1)$ is a valid challenge to $\mathcal{A}$ as in a real attack. \\
%  
% \noindent \textbf{Guess}: The adversary $\mathcal{A}$ outputs a guess $b'$ of $b$. If $b' = b$, $\mathcal{B}$ outputs $0$ (indicating that $Z=g^{t\alpha^{(2^m-1)}}_{m+l-1}$). Otherwise, it outputs $1$ (indicating that $Z$ is a random element in $\mathbb{G}_{m+l-1}$).\\ 
% 
% \noindent We conclude that $\mathcal{B}$ has the same advantage $\epsilon$ as $\mathcal{A}$, which must therefore be negligible, as desired. This completes the proof of Theorem 4.6. Note that once again this proof is also in the standard model and does not use random oracles. \hfill\qed 
% 
% 



\section{A CCA Secure Basic KAC using Symmetric Multilinear Maps}
\label{app_sec:CCAsecure2}

We now demonstrate how to extend the identity-based KAC construction using multilinear maps to obtain non-adaptive chosen ciphertext security. We again make use of the signature scheme coupled with the collusion resistant hash function that we introduced in Appendix \ref{app_sec:CCA1}. In this CCA secure construction, we force the class index value $i$ to be strictly less than $2^m-2$ instead of $2^m-1$ in the CPA secure construction.\\

\noindent\textbf{SetUp}$(1^{\lambda},m)$: \noindent\textbf{SetUp}$(1^{\lambda},(m,l))$: Set up the KAC system for $\mathcal{ID}$ consisting of all $m$ bit class identities with Hamming weight $l$, that is $N=|\mathcal{ID}|=\binom{m}{l}$. Since $1\leq l\leq m-1$, we have $N\leq 2^{m-2}$. Let $param'\leftarrow SetUp'(1^{\lambda},m+l-1)$ be the public parameters for a symmetric multilinear map, with $\mathbb{G}_{m+l-1}$ being the target group. Choose a random $\alpha\in \mathbb{Z}_q$. Set $X_j=g^{\alpha^{(2^j)}}_{1}$ for $0\leq j\leq m$.  Output the public parameter tuple $param$ as
\begin{equation}
 param = (param',\{X_j\}_{j\in\{0,\cdots,m\}})\nonumber
\end{equation}
\noindent Discard $\alpha$ after $param$ has been output.\\
 
\noindent \textbf{KeyGen}(): Randomly pick $\gamma\in \mathbb{Z}_q$. Set $msk=\gamma$ and $PK=g^{\gamma}_{l}$. Output the tuple $(msk,PK)$.\\
 
\noindent \textbf{Encrypt}$(param,PK,i,\mathcal{M})$: Run the $SigKeyGen$ algorithm to obtain a signature signing key $K_{SIG}$ and a verification key $V_{SIG} \in \mathbb{Z}_q$. Randomly choose $t\in\mathbb{Z}_q$. Compute 
\begin{equation}
 \mathcal{C}'=(g^{t}_{l},(PK.Y_i.g^{V_{SIG}}_{m-1})^{t},\mathcal{M}.g^{t\alpha^{(2^m-1)}}_{m+l-1})\nonumber
\end{equation} 
\noindent and output the ciphertext as
\begin{eqnarray}
 \mathcal{C}&=&(\mathcal{C}',Sign(\mathcal{C}',K_{SIG}),V_{SIG}) \nonumber
\end{eqnarray} 
 
\noindent \textbf{Extract}$(param,msk,\mathcal{S})$: Let $msk=(msk_1,msk_2)$. For the input subset of data class indices $\mathcal{S}$, the aggregate key is computed as 
\begin{equation}
 K_{\mathcal{S}} = \prod_{v\in\mathcal{S}}\left({Y_{2^m-1-v}}\right)^{msk_1}\nonumber
\end{equation} 
\noindent Recall that $Y_{2^m-1-v}$ can be computed as per Claim 4.3 for $j\in\mathcal{ID}$. Note that this is equivalent to setting $K_{\mathcal{S}}$ to $\prod_{v\in\mathcal{S}}{\left(g^{msk}_{m-1}\right)}^{\alpha^{2^m-1-v}}$.\\
 
\noindent \textbf{Decrypt}$(param,\mathcal{C},i,\mathcal{S},K_{\mathcal{S}})$: Let $\mathcal{C}=((c_0,c_1,c_2),\sigma,V_{SIG})$. Verify that $\sigma$ is a valid signature of $(c_0,c_1,c_2)$ under the key $V_{SIG}$. If not, output $\bot$. Also, if $i\notin\mathcal{S}$, output $\bot$. Otherwise, set 
\begin{eqnarray}
  SIG_{\mathcal{S}} &=& \prod_{v\in\mathcal{S}}g^{V_{SIG}}_{m-1}\nonumber\\
  a_{\mathcal{S}} &=& \prod_{v\in\mathcal{S},v\neq i}Y_{2^m-1-v+i}\nonumber\\
  b_{\mathcal{S}} &=& \prod_{v\in\mathcal{S}}Y_{2^m-1-v}\nonumber  
\end{eqnarray}
% \noindent Note that these can be computed as $1\leq i,v \leq N-1(=2^m-2)$. \emph{This is precisely why we allow only $N-1$ data classes}.  
\noindent Next, pick a random $w\in \mathbb{Z}_q$ and set
 \begin{eqnarray}
  \hat{h}_1 &=& (K_{\mathcal{S}}.SIG_{\mathcal{S}}.a_{\mathcal{S}}.(PK.Y_i.g^{V_{SIG}}_{m-1})^w)\nonumber\\
  \hat{h}_2 &=& (b_{\mathcal{S}}.g^w_{m-1}) \nonumber
 \end{eqnarray}
 \noindent Output the decrypted message 
 \begin{equation}
  \hat{\mathcal{M}} = c_2\frac{{e}(\hat{h}_1,c_0)}{{e}(\hat{h}_2,c_1)}\nonumber
 \end{equation}
\noindent The proof of correctness of this scheme is presented in Appendix \ref{app_sec:CCA1}. Note that the overhead for the ciphertext, aggregate key, public parameters, and the private and public keys, remains unchanged. The main change from the original scheme is in the fact that decryption requires a randomization value $w\in\mathbb{Z}_q$.

\subsubsection{Claim C.1.} \textit{For a given $i\in\mathcal{S}$, the pair $(\hat{h}_1,\hat{h}_2)$ is chosen from the following distribution 
\begin{equation}
\left(\left({Y_{2^m-1}}\right)^{-1}.\left(PK.Y_i.g^{V_{SIG}}_{m-1}\right)^x,\left(g_{m-1}\right)^x\right)\nonumber
\end{equation}
\noindent where $x$ is uniformly randomly chosen from $\mathbb{Z}_q$.}\\
\noindent{\textbf{Proof.}} Similar to the proof in Appendix \ref{app_sec:CCA1}.\\

Once again, note that the distribution $(\hat{h}_1,\hat{h}_2)$ depends \emph{only on the data class $i$ for the message $\mathcal{M}$ to be decrypted} and is \emph{completely independent of the subset $\mathcal{S}$ used to encrypt it}. We next prove the non-adaptive CCA security of this scheme. 

\subsubsection{Theorem C.2.} \textit{Let \textbf{Setup}$'$ be the setup algorithm for a symmetric multilinear map, and let the decisional $(m,l)$-Multilinear Diffie-Hellman Exponent assumption holds for {SetUp}$'$. Then our proposed construction of KAC for $N$ data classes presented in this section is non-adaptively CCA secure for $N=\binom{m}{l}$, where each data class number $i<2^m-2$.}

\subsubsection{Proof.} Let $\mathcal{A}$ be a poly-time adversary such that $|Adv_{\mathcal{A},N'}-\frac{1}{2}| > \epsilon$ for the proposed KAC system parameterized with an identity space $\mathcal{ID}'$ of size $N'$, and $\epsilon$ is a non-negligible positive constant. We build an algorithm $\mathcal{B}$ that has advantage at least $\epsilon$ in solving the decisional $(m,l)$-MDHE problem for \textbf{Setup}$'$. $\mathcal{B}$ takes as input a random $(m,l)$-MDHE challenge tuple $(param',\{X_j\}_{j\in\{0,\cdots,m\}},V,Z)$, where:
\begin{itemize}
 \item $param'\leftarrow SetUp'(1^{\lambda},m+l-1)$
 \item $X_j=g^{\alpha^{(2^j)}}_{1}$ for $0\leq j \leq m$
 \item $V=g^{t}_{l}$ for a random $t\in\mathbb{Z}_q$ (where $q$ is a $\lambda$ bit prime)
 \item $Z$ is either $g^{t\alpha^{(2^m-1)}}_{m+l-1}$ or a random element of $\mathbb{G}_{m+l-1}$.
\end{itemize}
\noindent $\mathcal{B}$ then proceeds as follows.\\

% \begin{enumerate}
\noindent \textbf{Commit:} $\mathcal{B}$ runs $\mathcal{A}$ and receives the set ${\mathcal{S}}^{*}$ of data classes that $\mathcal{A}$ wishes to be challenged on. $\mathcal{B}$ then randomly chooses a data class $i\in{\mathcal{S}}^{*}$ and provides it to $\mathcal{A}$.\\
 
\noindent \textbf{SetUp}: $\mathcal{B}$ should generate the public $param$, public key $PK$ and the aggregate key $K_{\overline{{\mathcal{S}}^{*}}}$ and provide them to $\mathcal{A}$. Algorithm $\mathcal{B}$ first runs the $SigKeyGen$ algorithm to obtain a signature signing key $K^{*}_{SIG}$ and a corresponding verification key $V^{*}_{SIG} \in \mathbb{Z}_q$. The various items to be provided to $\mathcal{A}$ are generated as follows.
%  \vspace{-0.6mm}
\begin{itemize}
  \item $param$ is set as $(param'',\{X_i\}_{i\in\{0,\cdots,m\}})\nonumber$.
  \item $PK$ is set as $\left({g^u_{l}}\right)/{\left(Y_i.g^{V^{*}_{SIG}}_{m-1}\right)}$ where $u$ is chosen uniformly at random from $\mathbb{Z}_q$.
  \item $\mathcal{B}$ then computes   
  \begin{equation}
   K_{\overline{{\mathcal{S}}^{*}}} = \prod_{v\notin{\mathcal{S}}^{*}}\frac{Y^{u}_{2^m-1-v}}{(Y_{2^m-1-v+i}).(g^{V^{*}_{SIG}}_{m-1})}\nonumber
  \end{equation}
  
\end{itemize}
 
\noindent Since the $g_{\mathbf{m}}$, $\alpha$, $u$ and $t$ values are chosen uniformly at random, \emph{all the parameters and keys have an identical distribution to that in the actual construction}.\\

\noindent\textbf{Query Phase 1}: Algorithm $\mathcal{A}$ now issues decryption queries. Let $(\mathcal{C},v)$ be a decryption query $\mathcal{C}$ is obtained by $\mathcal{A}$ using some subset $\mathcal{S}$ containing $v$. However, $\mathcal{B}$ is not given the knowledge of $\mathcal{S}$. Let $\mathcal{C}=((c_0,c_1,c_2),\sigma,V_{SIG})$. Algorithm $\mathcal{B}$ first runs $Verify$ to check if the signature $\sigma$ is valid on $(c_0,c_1,c_2)$ using $V_{SIG}$. If invalid, $\mathcal{B}$ returns $\bot$. If $V_{SIG} = V^{*}_{SIG}$, $\mathcal{B}$ outputs a random bit $b\in\{0,1\}$ and \emph{aborts} the simulation. Otherwise, the challenger picks a random $x\in\mathbb{Z}_q$. It then sets
\begin{eqnarray}
 \hat{h}_0&=&Y^{(V_{SIG}-V^{*}_{SIG})}.Y_v.Y^{-1}_i\nonumber\\
 \hat{h'}_0&=&(Y_{v+1}/Y_{i+1})^{\frac{1}{(V_{SIG}-V^{*}_{SIG})}}\nonumber \\
 \hat{h}_2&=&g^{x}_{\mathbf{m}}.Y^{\frac{1}{(V_{SIG}-V^{*}_{SIG})}}_1\nonumber\\
 \hat{h}_1&=&\left(\hat{h}_2\right)^u.\left(\hat{h}_0\right)^x.\left(\hat{h'}_0\right) \nonumber 
\end{eqnarray}
\noindent $\mathcal{B}$ responds with $\mathcal{M}'=c_2\frac{{e}(\hat{h}_1,c_0)}{{e}(\hat{h}_2,c_1)}$. 

\subsubsection{Claim C.3.} \textit{$\mathcal{B}$'s response is exactly as in a real attack scenario, that is, for some $x'$ chosen uniformly at random from $\mathbb{Z}_q$, we have} 
\begin{equation}
\hat{h}_1 = \left({Y_{2^m-1}}\right)^{-1}.\left(PK.Y_v.g^{V_{SIG}}_{m-1}\right)^{x'}  \text{ and }  \hat{h}_2 = g^{x'}_{m-1}\nonumber
\end{equation}

\noindent{\textbf{Proof.}} Similar to the proof in Appendix \ref{app_sec:CCA1}.\\


\noindent Thus, by the result in Claim C.2, $\mathcal{B}$'s response is identical to \textbf{Decrypt}$(\mathcal{C},v,\mathcal{S},K_{\mathcal{S}})$, even though $\mathcal{B}$ does not possess the knowledge of the subset $\mathcal{S}$ used by $\mathcal{A}$ to obtain $\mathcal{C}$.\\
 
\noindent \textbf{Challenge}: $\mathcal{A}$ picks at random two messages $\mathcal{M}_0$ and $\mathcal{M}_1$ from the set of possible plaintext messages in $\mathbb{G}_{2\mathbf{m}}$, and provides them to $\mathcal{B}$. $\mathcal{B}$ randomly picks $b\in\{0,1\}$, and sets 
\begin{eqnarray}
 \mathcal{C}&=&(V,V^u,\mathcal{M}_b.Z) \nonumber\\
 \mathcal{C}^{*}&=&(\mathcal{C},Sign(\mathcal{C},K^{*}_{SIG}),V^{*}_{SIG})\nonumber
\end{eqnarray}
\noindent The challenge posed to $\mathcal{A}$ is $(\mathcal{C}^{*},\mathcal{M}_0,\mathcal{M}_1)$. It can be easily shown that when $Z=g^{t\alpha^{(2^m-1)}}_{m+l-1}$ (i.e. the input to $\mathcal{B}$ is a valid $m$-MDHE tuple), then this is a valid challenge to $\mathcal{A}$ as in a real attack.\\

\noindent\textbf{Query Phase 2}: Same as in query phase 1.\\
 
\noindent \textbf{Guess}: The adversary $\mathcal{A}$ outputs a guess $b'$ of $b$. If $b' = b$, $\mathcal{B}$ outputs $0$ (indicating that $Z=g^{t\alpha^{(2^m-1)}}_{m+l-1}$). Otherwise, it outputs $1$ (indicating that $Z$ is a random element in $\mathbb{G}_{m+l-1}$).\\

\noindent It can be easily proved that the probability that $\mathcal{B}$ aborts the simulation as a result of one of the decryption queries by $\mathcal{A}$ is less than $\epsilon_2$ (from the existential unforgability property of the signature scheme). We conclude that $\mathcal{B}$ has the same advantage $\epsilon$ as $\mathcal{A}$, which must therefore be negligible, as desired. This completes the proof of Theorem C.3. \hfill\qed

Similar CCA secure extensions can also be made to the generalized KAC construction for the multi-user scenario.



\section{The Third KAC Construction}

\subsection{Correctness}
\label{app_sec:proof_correctness_3}

Correctness of the third KAC construction may be established as follows.

\begin{equation}
 \begin{split}
  \hat{\mathcal{M}}&=c_{m+2}\frac{{e}(K_{\mathcal{S}},c_0)}{{e}(c_{m+1}.a_{\mathcal{S}},PK_2)}\\
  &=c_{m+2}\frac{e\left(\left(\prod_{v\in\mathcal{S}}{Y_{v}}\right)^x,g^{t}_1\right)}{e\left(\left(g^{\gamma}_m.{Y_i}.\prod_{v\in\mathcal{S},v\neq i}Y_{v}\right)^{t},g^x_1\right)}\\
  &=\frac{c_{m+2}}{e(\left(g^{\gamma}_m\right)^{t},g^{x}_1)}\\
  &=\mathcal{M}\nonumber
 \end{split}
\end{equation}


\subsection{Security In The Generic Multilinear Map Model}
\label{app_sec:proofgeneric}

In this section, we prove that the basic version of our third KAC construction described in Section \ref{subsec:construction_third} is adaptively CPA secure in the generic multilinear map model . In particular, we demonstrate that with a prime group order parameter $q\approx 2^{\lambda}$, the scheme achieves $\lambda$-bit security. We state and prove the following theorem.

\subsubsection{Theorem D.1.} \textit{Any generic adversary $\mathcal{A}$ that can make at most a polynomial number of queries to} (\textbf{Encode},\textbf{Mult},\textbf{Pair}) \textit{has negligible advantage in breaking the adaptive security of the KAC construction presented in Section} \ref{subsec:construction_third}\textit{, provided that $1/q$ is negligible.}

\subsubsection{Proof.} Let $\mathcal{A}$ be an adaptive adversary under the generic model and let $\mathcal{B}$ be a challenger that plays the following game with $\mathcal{A}$:\\

\noindent\textbf{SetUp}: Challenger $\mathcal{B}$ sets up the system for $\mathcal{ID}$ consisting of all $m$ bit class identities. $\mathcal{B}$ generates random $\alpha_{j,b}\in\mathbb{Z}_q$ for $j=0,\cdots,m-1$, and $b=0,1$. $\mathcal{B}$ also generates random $\gamma,x,t\in\mathbb{Z}_q$. $\mathcal{A}$ receives the following:

\begin{itemize}
 \item $X_{j,b}=\xi({\alpha_{j,b}},1)$ for $j=0,\cdots,m-1$, and $b=0,1$
 \item $PK=(\xi({\gamma},{m}),\xi(x,1))$ 
 
\end{itemize}

\noindent\textbf{Oracle Query Phase.} $\mathcal{A}$ adaptively issues queries to (\textbf{Encode},\textbf{Mult},\textbf{Pair}).\\

\noindent\textbf{Commit.} Algorithm $\mathcal{A}$ commits to a set ${\mathcal{S}} \subset \mathcal{ID}$ of data classes that it wishes to attack. Since collusion attacks are allowed in our framework, $\mathcal{B}$ furnishes $\mathcal{A}$ with the aggregate key $K_{\overline{\mathcal{S}}}$ computed as

\begin{equation}
 K_{\overline{\mathcal{S}}} = \xi\left(x\sum_{v\notin\mathcal{S}}{\prod_{j=0}^{m-1}\alpha_{j,v_j}},m\right)\nonumber
\end{equation}
\noindent $\mathcal{B}$ also chooses $i\in\mathcal{S}$ and communicates the same to $\mathcal{A}$.\\

\noindent\textbf{Challenge}: To make a challenge query, $\mathcal{A}$  randomly generates $\hat{m}_0,\hat{m}_1\in\mathbb{Z}_2q$ and provides these to $\mathcal{B}$. $\mathcal{B}$ in turn randomly chooses $t\in\mathbb{Z}_q$ and a random $\hat{b}\in\{0,1\}$, and sets
\begin{eqnarray}
 c_0&=&\xi(t,1)\nonumber\\
 c_{j+1}&=&\xi(t\alpha_{j,\left(1-i_{j}\right)}) \text{ for } j=0,1,\cdots,m-1\nonumber\\
 c_{m+1}&=&\xi(t(\gamma+\prod_{j=0}^{m-1}\alpha_{j,i_j}),m)\nonumber\\
 c_{m+2}&=& \xi(\hat{m}_{\hat{b}}+\gamma xt,m+1)\nonumber
\end{eqnarray}
\noindent Finally, $\mathcal{B}$ sets 
\begin{equation}
 \mathcal{C}=(\{c_j\}_{j\in\{0,\cdots,m+2\}})\nonumber
\end{equation}
\noindent and provides the challenge to $\mathcal{A}$ as $(\mathcal{C},\xi(\hat{m}_0,m+1),\xi(\hat{m}_1,m+1))$.\\
 
 
\noindent\textbf{Guess}: $\mathcal{A}$ outputs a guess $\hat{b'}$ of $\hat{b}$. If $\hat{b'} = \hat{b}$, $\mathcal{A}$ wins the game.\\

\noindent We now assume that instead of choosing random values for the set of parameters 
\begin{equation}
 (\{\alpha_{j,b}\}_{j\in\{0,\cdots,m-1\},b\in\{0,1\}},\gamma,x,t,\hat{m}_0,\hat{m}_1)\nonumber
\end{equation}
\noindent the algorithm $\mathcal{B}$ treats them as formal variables and maintains a list of tuples $L=\{(p,l,\epsilon)\}$, where $p$ is a polynomial in these formal variables, $l$ is the group index and $\epsilon\in\{0,1\}^{n}$. The game now proceeds through the following stages:

\begin{itemize}
\item $\mathcal{B}$ initializes the list with the following tuples:\\
% \begin{itemize}
 \subitem $(\alpha_{j,b},1,\xi_{2j+b})$ for randomly generated $\xi_{2j+b}\in\{0,1\}^{n}$, where $j\in\{0,\cdots,m-1\}$ and $b\in\{0,1\}$
 \subitem $(\gamma,m,\xi{2m})$ for a randomly generated $\xi_{2m}\in\{0,1\}^{n}$
 \subitem $(x,1,\xi_{2m+1})$ for a randomly generated $\xi_{2m+1}\in\{0,1\}^{n}$\\
%  \item $(t,1,\xi_{2m+2})$ for a randomly generated $\xi_{2m+2}\in\{0,1\}^{n}$
% \end{itemize}

\noindent Thus intially, $|L|=2m+2$. $\mathcal{B}$ supplies the set of strings $\{\xi_j\}_{j\in\{0,\cdots,2m+2\}}$ to $\mathcal{A}$.\\ 


\item $\mathcal{A}$ is allowed at most a polynomial number of (\textbf{Encode},\textbf{Mult},\textbf{Pair}) queries to which $\mathcal{B}$ responds as follows:\\

\subitem \textbf{Encode}$(x,l)$: If $x\notin \mathbb{Z}_q$ or $i\notin\{1,\cdots,m+1\}$, $\mathcal{B}$ returns $\bot$. Otherwise, $\mathcal{B}$ looks for a tuple $(p_x,l,\xi)\in L$, where $p_x$ is a constant polynomial equal to $x$. If such a tuple exists, $\mathcal{B}$ returns $\xi$. Otherwise, $\mathcal{B}$ generates a random $\xi\in\{0,1\}^{n}$. The tuple $(p_x,l,\xi)$ is added to $L$ and $\mathcal{B}$ responds with $\xi$.\\

\subitem \textbf{Mult}$(\xi_{k_0},\xi_{k_1},b)$: $\mathcal{B}$ searches in $L$ for the pair of tuples $(p_{k_0},l_{k_0},\xi_{k_0})$ and $(p_{k_1},l_{k_1},\xi_{k_1})$. Unless both of them exist, $\mathcal{B}$ returns $\bot$. Also, if both tuples are available but $l_{k_0}\neq l_{k_1}$, $\mathcal{B}$ returns $\bot$. Otherwise, $\mathcal{B}$ searches in $L$ for a tuple of the form $(p_k,l_k,\xi_k)$, where $p_k=p_{k_0}+(-1)^bp_{k_1}$ and $l_k\equiv l_{k_0}\equiv l_{k_1}$. If such a tuple is found, $\mathcal{B}$ responds with $\xi_k$. If not, $\mathcal{B}$ generates a random $\xi_k\in\{0,1\}^{n}$, augments $L$ by adding the tuple $(p_k,l_k,\xi_k)$ and returns $\xi_k$.\\

\subitem \textbf{Pair}$(\xi_{k_0},\xi_{k_1})$: $\mathcal{B}$ searches in $L$ for the pair of tuples $(p_{k_0},l_{k_0},\xi_{k_0})$ and $(p_{k_1},l_{k_1},\xi_{k_1})$. Unless both of them exist, $\mathcal{B}$ returns $\bot$. Also, if both tuples are available but $l_{k_0} + l_{k_1}>m+1$, $\mathcal{B}$ returns $\bot$. Otherwise, $\mathcal{B}$ searches in $L$ for a tuple of the form $(p'_k,l'_k,\xi'_k)$, where $p'_k=p_{k_0}.p_{k_1}$ and $l'_k\equiv l_{k_0} + l_{k_1}$. If such a tuple is found, $\mathcal{B}$ responds with $\xi'_k$. If not, $\mathcal{B}$ generates a random $\xi'_k\in\{0,1\}^{n}$, augments $L$ by adding the tuple $(p'_k,l'_k,\xi'_k)$ and returns $\xi'_k$.\\ 

\noindent We stress the fact that in each query to any of the three algorithms, \emph{at most one} new tuple is added to $L$, and no tuple can have index $j>m+1$. Note that $\mathcal{B}$ can make the string responses $\xi$ to $\mathcal{A}$ arbitrarily long, and thus, hard to guess. Hence, without loss of generality, we assume that all \textbf{Mult} and \textbf{Pair} queries made by $\mathcal{A}$ are precisely on strings furnished by $\mathcal{B}$.\\

\item $\mathcal{A}$ is allowed to commit to a set $\mathcal{S}$ and query for the collusion aggregate key $K_{\overline{\mathcal{S}}}$. In response, $\mathcal{B}$ adds the tuple $\left(x\sum_{v\notin\mathcal{S}}{\prod_{j=0}^{m-1}\alpha_{j,v_j}},m,\xi\right)$ for randomly generated $\xi\in\{0,1\}^{n}$, which is given as response to $\mathcal{A}$. $\mathcal{B}$ also chooses $i\in\mathcal{S}$ and communicates the same to $\mathcal{A}$.\\ 

\item Finally, $\mathcal{A}$ is allowed to make a single encryption query on the class $i\in\mathcal{S}$. $\mathcal{B}$ creates a new formal variable $\hat{m}$ and adds the following tuples to its list $L$:\\

 \subitem $(t,1,\xi)$
 \subitem $(t\alpha_{j,\left(1-i_{j}\right)},1,\xi_{j}) \text{ for } j=0,1,\cdots,m-1$
 \subitem $(t(\gamma+\prod_{j=0}^{m-1}\alpha_{j,i_j}),m,\xi_{m})$
 \subitem $(\hat{m}+\gamma xt,m+1,\xi_{m+1})$
 \subitem $(\hat{m}_0,m+1,\xi_{m+2})$
 \subitem $(\hat{m}_1,m+1,\xi_{m+3})$\\

\noindent Once again $\xi$ and $\xi_j, j\in\{0,\cdots,m+3\}$ are randomly generated strings in $\{0,1\}^{n}$ that are provided to $\mathcal{A}$ as response.\\

\item $\mathcal{A}$ outputs a random $\hat{b'}\in\{0,1\}$.\\

\item At this point, $\mathcal{B}$ chooses random values for $\alpha_{j,b},\gamma,x,t$ and asks $\mathcal{A}$ for two random messages $m_0$ and $m_1$. $\mathcal{B}$ also randomly chooses $,\hat{b}\in\{0,1\}$ and sets $\hat{m}=\hat{m}_{\hat{b}}$.

\end{itemize}

\noindent We denote by $\Upsilon$ a \emph{false polynomial equality} event where, for two random tuples $(p,l,\xi)$ and $(p',l',\xi')$ in the list $L$ such that $l=l'$, we have $p(\alpha_{j,b},\cdots)=p'(\alpha_{j,b},\cdots)$ even though $p\not\equiv p'$. In case an instance of $\Upsilon$ occurs, $\mathcal{B}$ fails to simulate the oracle perfectly. We say that $\mathcal{A}$ wins the game if $\hat{b}=\hat{b'}$ or an instance of the event $\Upsilon$ occurs. 

\begin{table}[!t]
\centering
\captionsetup{font=scriptsize}
\caption{Upper Bounds on Contributions to Length of $L$}
\label{tab:tuple}
\scalebox{1.0}{
\begin{tabular}{|c|c|}
  \hline
  \textbf{Query Stage} & \textbf{Maximum Contribution to $|L|$}\\\hline
  SetUp & $2m+2$\\\hline
  Oracle Query Phase & $Q_e+Q_m+Q_p$\\\hline
  Commit & $1$\\\hline
  Challenge & $m+5$\\\hline
  \textbf{Total} & $Q_e+Q_m+Q_p+3m+8$\\\hline
\end{tabular}}
\end{table}

We now look at the probability that a random choice of values for the formal variables
\begin{equation}
(\alpha_{j,b},\gamma,x,t,m_0,m_1)\in\mathbb{Z}^{\left(2m+5\right)}_q\nonumber
\end{equation}
\noindent results in the event $\Upsilon$. First, we make the following observations.

\subsubsection{Observation D.2.}\emph{The maximum degree of any polynomial in $L$ is at most $m+1$}.
\subsubsection{Observation D.3.}\emph{Substituting the formal variable $\hat{m}$ with $\hat{m}_{\hat{b}}$ results in no instances of the false polynomial equality event $\Upsilon$.}\\

\noindent It follows from the Swartz-Zippel lemma \cite{moshkovitz2010alternative} that the probability that a randomly chosen pair of polynomials in $L$ evaluate to the same value for a random choice of variable values, is upper bounded by $(m+1)/q$. Next, assume that $\mathcal{A}$ makes $Q_E$ queries to \textbf{Encode}, $Q_M$ queries to \textbf{Mult} and $Q_P$ queries to \textbf{Pair} during \textbf{Oracle Query Phase}. Table \ref{tab:tuple} summarizes the maximum possible contributions to $|L|$ by the tuples added by $\mathcal{B}$ at different query stages. Note that $|L|$ is upper bounded by $(Q_e+Q_m+Q_p+3m+8)$. It easily follows that the probability of a false polynomial equality event $\Upsilon$ is upper bounded as
\begin{equation}
 Pr(\Upsilon)\leq \left(Q_e+Q_m+Q_p+3m+8\right)^2\left(m+1\right)/2q\nonumber
\end{equation}
\noindent If the event $\Upsilon$ does not occur, $\mathcal{B}$ simulates the oracle in response to $\mathcal{A}$'s queries perfectly and, from $\mathcal{A}$'s view, $\hat{b}$ is independent as it was chosen after the simulation. Hence we have 

\begin{equation}
 Pr[\hat{b}=\hat{b'}\mid\overline{\Upsilon}]=1/2\nonumber
\end{equation}
\noindent This in turn gives us the following relations:
\begin{eqnarray}
 Pr[\hat{b}=\hat{b'}]\geq Pr[\hat{b}=\hat{b'}\mid\overline{\Upsilon}]Pr[\overline{\Upsilon}]=\frac{1-Pr[\Upsilon]}{2}\nonumber\\
 Pr[\hat{b}=\hat{b'}]\leq Pr[\hat{b}=\hat{b'}\mid\overline{\Upsilon}]Pr[\Upsilon] + Pr[{\Upsilon}] = \frac{1+Pr[\Upsilon]}{2}\nonumber
\end{eqnarray}
\noindent From this, it is straightforward to conclude that the advantage of the generic adversary $\mathcal{A}$ may be upper bounded as follows:
\begin{equation}
\begin{split}
 |Adv_{\mathcal{A},2^m}-\frac{1}{2}| &= |Pr[\hat{b}=\hat{b'}]|\\
 &\leq {Pr[\Upsilon]}/{2}\\
 &= \left(Q_e+Q_m+Q_p+3m+8\right)^2\left(m+1\right)/4q\nonumber
\end{split} 
\end{equation}

\noindent For $Q_e,Q_m,Q_p,m$ polynomial in the security parameter $\lambda$, this quantity is negligible provided that $1/q$ is negligible, or in particular, $q\approx 2^{\lambda}$, as desired. This completes the proof of Theorem D.1.\hfill\qed 